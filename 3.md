

## ‚úÖ Target Folder Structure (Industry-style)

```txt
src/
 ‚îú‚îÄ‚îÄ features/
 ‚îÇ   ‚îî‚îÄ‚îÄ todos/
 ‚îÇ       ‚îú‚îÄ‚îÄ todo.types.ts
 ‚îÇ       ‚îú‚îÄ‚îÄ todo.reducer.ts
 ‚îÇ       ‚îú‚îÄ‚îÄ todo.context.tsx
 ‚îÇ       ‚îú‚îÄ‚îÄ todo.hooks.ts
 ‚îÇ       ‚îî‚îÄ‚îÄ components/
 ‚îÇ           ‚îú‚îÄ‚îÄ AddTodo.tsx
 ‚îÇ           ‚îî‚îÄ‚îÄ TodoList.tsx
 ‚îî‚îÄ‚îÄ App.tsx
```

üëâ This is **feature-based architecture**
üëâ Used in real companies (React, Angular, Vue)

---

# üß† RULE TO REMEMBER

> **One feature = one folder**

Todos logic stays together.
No more jumping files.

---

# 1Ô∏è‚É£ `todo.types.ts` (DATA ONLY)

```ts
// src/features/todos/todo.types.ts

export type Todo = {
  id: number;
  text: string;
  completed: boolean;
};

export type State = {
  todos: Todo[];
  loading: boolean;
};

export type Action =
  | { type: "ADD_TODO"; payload: string }
  | { type: "TOGGLE_TODO"; payload: number }
  | { type: "DELETE_TODO"; payload: number }
  | { type: "START_LOADING" }
  | { type: "STOP_LOADING" };
```

### Why this file exists

* No React here
* Pure business types
* Can be reused by API, tests, reducers

---

# 2Ô∏è‚É£ `todo.reducer.ts` (RULES ONLY)

```ts
// src/features/todos/todo.reducer.ts

import { State, Action } from "./todo.types";

export function todoReducer(state: State, action: Action): State {
  switch (action.type) {
    case "START_LOADING":
      return { ...state, loading: true };

    case "STOP_LOADING":
      return { ...state, loading: false };

    case "ADD_TODO":
      return {
        ...state,
        todos: [
          ...state.todos,
          {
            id: Date.now(),
            text: action.payload,
            completed: false,
          },
        ],
      };

    case "TOGGLE_TODO":
      return {
        ...state,
        todos: state.todos.map((todo) =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };

    case "DELETE_TODO":
      return {
        ...state,
        todos: state.todos.filter((todo) => todo.id !== action.payload),
      };

    default:
      return state;
  }
}
```

### üîë Mental model

> ‚ÄúIf state changes, it happens here ‚Äî nowhere else‚Äù

---

# 3Ô∏è‚É£ `todo.context.tsx` (STATE CREATION + SHARING)

```tsx
// src/features/todos/todo.context.tsx

import React from "react";
import { State, Action } from "./todo.types";
import { todoReducer } from "./todo.reducer";

type TodoContextType = {
  state: State;
  dispatch: React.Dispatch<Action>;
};

export const TodoContext =
  React.createContext<TodoContextType | null>(null);

export function TodoProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = React.useReducer(todoReducer, {
    todos: [],
    loading: false,
  });

  return (
    <TodoContext.Provider value={{ state, dispatch }}>
      {children}
    </TodoContext.Provider>
  );
}
```

### Why reducer + context live together

Because:

* Reducer **creates state**
* Context **shares state**

They are married üíç

---

# 4Ô∏è‚É£ `todo.hooks.ts` (SAFE ACCESS)

```ts
// src/features/todos/todo.hooks.ts

import { useContext } from "react";
import { TodoContext } from "./todo.context";

export function useTodos() {
  const context = useContext(TodoContext);

  if (!context) {
    throw new Error("useTodos must be used inside TodoProvider");
  }

  return context;
}
```

### Why this matters

* Clean imports
* No repeated `useContext`
* Easy refactor later

---

# 5Ô∏è‚É£ `AddTodo.tsx` (WRITE ONLY)

```tsx
// src/features/todos/components/AddTodo.tsx

import React from "react";
import { useTodos } from "../todo.hooks";

export function AddTodo() {
  const { dispatch } = useTodos();
  const [text, setText] = React.useState("");

  const addTodo = () => {
    if (!text.trim()) return;

    dispatch({ type: "START_LOADING" });

    setTimeout(() => {
      dispatch({ type: "ADD_TODO", payload: text });
      dispatch({ type: "STOP_LOADING" });
    }, 500);

    setText("");
  };

  return (
    <div>
      <input
        value={text}
        onChange={(e) => setText(e.target.value)}
        placeholder="New todo"
      />
      <button onClick={addTodo}>Add</button>
    </div>
  );
}
```

---

# 6Ô∏è‚É£ `TodoList.tsx` (READ + ACTIONS)

```tsx
// src/features/todos/components/TodoList.tsx

import { useTodos } from "../todo.hooks";

export function TodoList() {
  const { state, dispatch } = useTodos();

  if (state.loading) return <p>Loading...</p>;

  return (
    <ul>
      {state.todos.map((todo) => (
        <li key={todo.id}>
          <span
            onClick={() =>
              dispatch({ type: "TOGGLE_TODO", payload: todo.id })
            }
            style={{
              cursor: "pointer",
              textDecoration: todo.completed ? "line-through" : "none",
            }}
          >
            {todo.text}
          </span>

          <button
            onClick={() =>
              dispatch({ type: "DELETE_TODO", payload: todo.id })
            }
          >
            ‚ùå
          </button>
        </li>
      ))}
    </ul>
  );
}
```

---

# 7Ô∏è‚É£ `App.tsx` (COMPOSITION ONLY)

```tsx
import { TodoProvider } from "./features/todos/todo.context";
import { AddTodo } from "./features/todos/components/AddTodo";
import { TodoList } from "./features/todos/components/TodoList";

export default function App() {
  return (
    <TodoProvider>
      <h1>Production Todo App</h1>
      <AddTodo />
      <TodoList />
    </TodoProvider>
  );
}
```

### App does NOT:

‚ùå Manage state
‚ùå Know business logic

It only **composes features**.

---

# üß† BIG TAKEAWAY (VERY IMPORTANT)

You just learned:

‚úÖ Feature-based architecture
‚úÖ Clean separation of concerns
‚úÖ Scalable React pattern
‚úÖ Foundation of Redux Toolkit
‚úÖ How real teams structure apps

This is **NOT beginner knowledge**.

---

## üî• What‚Äôs NEXT (I decide again)

Next logical step is:

> ## **Async API (real fetch) + error handling**

You‚Äôll learn:

* `useEffect`
* async actions
* error state
* clean API layer

This is where **90% of real apps live**.

If you‚Äôre ready, just say:

üëâ **‚ÄúNext‚Äù**

And we continue üöÄ
