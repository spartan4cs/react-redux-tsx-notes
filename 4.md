

# ğŸ¯ TODAYâ€™S GOAL (VERY CLEAR)

We will add **REAL async behavior** properly:

âœ… `useEffect`
âœ… API layer (clean separation)
âœ… loading & error states
âœ… async flow using **the SAME reducer + context pattern**

âš ï¸ No Redux yet â€” because **this is how Redux logic actually works internally**.

---

## ğŸ§  First: The BIG IDEA (Before Code)

In production:

âŒ UI should NOT call `fetch()` directly
âŒ UI should NOT handle business logic

âœ… UI should say **WHAT happened**
âœ… Logic should live **outside components**

So we introduce a **service layer**.

---

# ğŸš€ STEP 1 â€” Create API Service (Fake Backend)

### ğŸ“ `src/features/todos/todo.api.ts`

```ts
import { Todo } from "./todo.types";

let fakeTodos: Todo[] = [
  { id: 1, text: "Learn async flow", completed: false },
  { id: 2, text: "Understand reducer pattern", completed: true },
];

export function fetchTodos(): Promise<Todo[]> {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(fakeTodos);
    }, 800);
  });
}

export function createTodo(text: string): Promise<Todo> {
  return new Promise((resolve) => {
    setTimeout(() => {
      const newTodo = {
        id: Date.now(),
        text,
        completed: false,
      };
      fakeTodos.push(newTodo);
      resolve(newTodo);
    }, 500);
  });
}
```

### ğŸ”‘ Why this exists

* Simulates backend
* Can be replaced by real API later
* UI doesnâ€™t care where data comes from

---

# ğŸš€ STEP 2 â€” Extend State & Actions

### ğŸ“ `todo.types.ts` (UPDATED)

```ts
export type State = {
  todos: Todo[];
  loading: boolean;
  error: string | null;
};

export type Action =
  | { type: "FETCH_START" }
  | { type: "FETCH_SUCCESS"; payload: Todo[] }
  | { type: "FETCH_ERROR"; payload: string }
  | { type: "ADD_TODO"; payload: Todo };
```

### Why this matters

This is **classic async state**:

```
start â†’ success | error
```

Every production app uses this.

---

# ğŸš€ STEP 3 â€” Reducer Handles ASYNC STATES

### ğŸ“ `todo.reducer.ts` (UPDATED)

```ts
import { State, Action } from "./todo.types";

export function todoReducer(state: State, action: Action): State {
  switch (action.type) {
    case "FETCH_START":
      return { ...state, loading: true, error: null };

    case "FETCH_SUCCESS":
      return { ...state, loading: false, todos: action.payload };

    case "FETCH_ERROR":
      return { ...state, loading: false, error: action.payload };

    case "ADD_TODO":
      return { ...state, todos: [...state.todos, action.payload] };

    default:
      return state;
  }
}
```

### ğŸ”¥ IMPORTANT

Reducer **does not know async exists**
It only reacts to actions.

This is **clean architecture**.

---

# ğŸš€ STEP 4 â€” Trigger Async Logic in Provider (KEY STEP)

### ğŸ“ `todo.context.tsx` (UPDATED)

```tsx
import React, { useEffect } from "react";
import { todoReducer } from "./todo.reducer";
import { fetchTodos, createTodo } from "./todo.api";
import { State, Action } from "./todo.types";

type TodoContextType = {
  state: State;
  loadTodos: () => void;
  addTodo: (text: string) => void;
};

export const TodoContext =
  React.createContext<TodoContextType | null>(null);

export function TodoProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = React.useReducer(todoReducer, {
    todos: [],
    loading: false,
    error: null,
  });

  const loadTodos = async () => {
    dispatch({ type: "FETCH_START" });
    try {
      const todos = await fetchTodos();
      dispatch({ type: "FETCH_SUCCESS", payload: todos });
    } catch {
      dispatch({ type: "FETCH_ERROR", payload: "Failed to load todos" });
    }
  };

  const addTodo = async (text: string) => {
    const todo = await createTodo(text);
    dispatch({ type: "ADD_TODO", payload: todo });
  };

  useEffect(() => {
    loadTodos();
  }, []);

  return (
    <TodoContext.Provider value={{ state, loadTodos, addTodo }}>
      {children}
    </TodoContext.Provider>
  );
}
```

### ğŸš¨ THIS IS HUGE

We moved:

* async logic âŒ out of UI
* into Provider âœ…

This is **exactly how Redux Thunks work**.

---

# ğŸš€ STEP 5 â€” Update Hook

### ğŸ“ `todo.hooks.ts`

```ts
import { useContext } from "react";
import { TodoContext } from "./todo.context";

export function useTodos() {
  const context = useContext(TodoContext);
  if (!context) {
    throw new Error("useTodos must be used inside TodoProvider");
  }
  return context;
}
```

---

# ğŸš€ STEP 6 â€” Components Become VERY SIMPLE ğŸ˜

### ğŸ“ `AddTodo.tsx`

```tsx
import { useState } from "react";
import { useTodos } from "../todo.hooks";

export function AddTodo() {
  const [text, setText] = useState("");
  const { addTodo } = useTodos();

  return (
    <div>
      <input value={text} onChange={(e) => setText(e.target.value)} />
      <button onClick={() => addTodo(text)}>Add</button>
    </div>
  );
}
```

---

### ğŸ“ `TodoList.tsx`

```tsx
import { useTodos } from "../todo.hooks";

export function TodoList() {
  const { state } = useTodos();

  if (state.loading) return <p>Loading...</p>;
  if (state.error) return <p>{state.error}</p>;

  return (
    <ul>
      {state.todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}
```

---

# ğŸ§  WHAT YOU JUST LEARNED (BIG DEAL)

You now understand:

âœ… Real async state handling
âœ… Clean separation of concerns
âœ… Why reducers scale
âœ… How Redux Toolkit works internally
âœ… How professional React apps are built

This is **intermediate â†’ advanced React**.

---
