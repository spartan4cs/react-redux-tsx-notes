Perfect ğŸ‘
This is the **exact moment** where Context starts to feel uncomfortable â€” and thatâ€™s the lesson.

We will **add a second reducer (Users)** using **Context**, and Iâ€™ll show you **why this becomes messy** (on purpose).

No Redux yet.

---

# ğŸ§  What we are adding (VERY CLEAR)

So far we have:

âœ… **Auth state**

```ts
{ user: string | null }
```

Now we add:

âœ… **Users state**

```ts
{ users: string[] }
```

This means:

* **2 reducers**
* **2 contexts**
* **2 providers**

This is how people *naturally* try to scale Context.

---

# ğŸ—‚ UPDATED FILE STRUCTURE

```txt
src/
 â”œâ”€â”€ auth/
 â”‚   â”œâ”€â”€ auth.types.ts
 â”‚   â”œâ”€â”€ auth.reducer.ts
 â”‚   â”œâ”€â”€ auth.context.tsx
 â”‚   â””â”€â”€ auth.hook.ts
 â”œâ”€â”€ users/
 â”‚   â”œâ”€â”€ users.types.ts
 â”‚   â”œâ”€â”€ users.reducer.ts
 â”‚   â”œâ”€â”€ users.context.tsx
 â”‚   â””â”€â”€ users.hook.ts
 â””â”€â”€ App.tsx
```

---

# 1ï¸âƒ£ `users.types.ts`

```ts
// src/users/users.types.ts

export type UsersState = {
  users: string[];
};

export type UsersAction =
  | { type: "ADD_USER"; payload: string }
  | { type: "REMOVE_USER"; payload: string };
```

---

# 2ï¸âƒ£ `users.reducer.ts`

```ts
// src/users/users.reducer.ts

import { UsersState, UsersAction } from "./users.types";

export function usersReducer(
  state: UsersState,
  action: UsersAction
): UsersState {
  switch (action.type) {
    case "ADD_USER":
      return { users: [...state.users, action.payload] };

    case "REMOVE_USER":
      return {
        users: state.users.filter((u) => u !== action.payload),
      };

    default:
      return state;
  }
}
```

---

# 3ï¸âƒ£ `users.context.tsx`

```tsx
// src/users/users.context.tsx

import React from "react";
import { usersReducer } from "./users.reducer";
import { UsersState, UsersAction } from "./users.types";

type UsersContextType = {
  state: UsersState;
  dispatch: React.Dispatch<UsersAction>;
};

const UsersContext = React.createContext<UsersContextType | null>(null);

export function UsersProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = React.useReducer(usersReducer, {
    users: [],
  });

  return (
    <UsersContext.Provider value={{ state, dispatch }}>
      {children}
    </UsersContext.Provider>
  );
}

export { UsersContext };
```

---

# 4ï¸âƒ£ `users.hook.ts`

```ts
// src/users/users.hook.ts

import { useContext } from "react";
import { UsersContext } from "./users.context";

export function useUsers() {
  const context = useContext(UsersContext);

  if (!context) {
    throw new Error("useUsers must be used inside UsersProvider");
  }

  return context;
}
```

---

# 5ï¸âƒ£ Update `App.tsx` (HERE IS THE PAIN)

```tsx
import { AuthProvider } from "./auth/auth.context";
import { useAuth } from "./auth/auth.hook";

import { UsersProvider } from "./users/users.context";
import { useUsers } from "./users/users.hook";

function AuthPanel() {
  const { state, dispatch } = useAuth();

  return (
    <div>
      <h2>User: {state.user ?? "Not logged in"}</h2>

      <button
        onClick={() =>
          dispatch({ type: "LOGIN", payload: "Akhil" })
        }
      >
        Login
      </button>

      <button onClick={() => dispatch({ type: "LOGOUT" })}>
        Logout
      </button>
    </div>
  );
}

function UsersPanel() {
  const { state, dispatch } = useUsers();

  return (
    <div>
      <h3>Users</h3>

      <button
        onClick={() =>
          dispatch({ type: "ADD_USER", payload: "User " + Date.now() })
        }
      >
        Add User
      </button>

      <ul>
        {state.users.map((u) => (
          <li key={u}>{u}</li>
        ))}
      </ul>
    </div>
  );
}

export default function App() {
  return (
    <AuthProvider>
      <UsersProvider>
        <h1>User Dashboard</h1>
        <AuthPanel />
        <UsersPanel />
      </UsersProvider>
    </AuthProvider>
  );
}
```

---

# ğŸš¨ STOP AND FEEL THE PROBLEM (IMPORTANT)

Look at this part carefully:

```tsx
<AuthProvider>
  <UsersProvider>
    <AuthPanel />
    <UsersPanel />
  </UsersProvider>
</AuthProvider>
```

### Problems starting to appear:

âŒ Provider nesting
âŒ Order matters
âŒ More features = more wrappers
âŒ Hard to share state across features
âŒ Hard to add cross-feature actions

This is **why Redux exists**.

---

# ğŸ§  VERY IMPORTANT REALIZATION

> Context works GREAT for **1â€“2 global states**
> Context becomes painful with **many reducers**

You just experienced the pain **naturally** â€” not theoretically.

---

# ğŸ” CLICK â†’ RENDER FLOW (STILL SAME)

Even with two reducers:

```
click
â†’ dispatch (auth OR users)
â†’ correct reducer runs
â†’ state updates
â†’ only that context consumers re-render
```

So logic is fine â€” **architecture is the issue**.

---

# ğŸ† WHAT YOU JUST LEARNED (BIG)

âœ… How multiple contexts scale
âœ… Why provider nesting is a problem
âœ… Why Redux Toolkit is useful
âœ… You felt the pain yourself (best way to learn)

---

## ğŸ”œ NEXT STEP (VERY IMPORTANT)

Now the migration will feel **obvious and justified**.

ğŸ‘‰ We will **replace ALL of this** with:

* ONE Redux store
* NO nested providers
* SAME reducers logic

### Just reply:

**â€œmigrate to reduxâ€**

And weâ€™ll do it **calmly, step by step**, mapping old â†’ new ğŸ’™
